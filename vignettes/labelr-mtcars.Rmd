---
title: "A Motor Trend Cars-based Intro to labelr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Motor Trend Cars-based Intro to labelr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "### >"
)
```
## The Motor Trend Cars (mtcars) Data Frame
mtcars frequently appears in R examples and demonstrations, so, let's use
it to lock in our understanding of labelr.
<br>
<br>

Let's start by loading labelr.
```{r setup}
library(labelr)
```

Next, we'll assign mtcars to a new data.frame that we'll call mt2.

```{r}
mt2 <- mtcars
```

First, let's inject a missing row into the data, to keep things interesting

```{r}
mt2[1, 1:11] <- NA
rownames(mt2)[1] <- "Missing Car"
```

## Add a FRAME Label
Let's add a "frame label," which describes the data.frame overall.

```{r}
mt2 <- add_frame_lab(mt2, frame.lab = "Data extracted from the 1974 Motor
Trend US magazine, comprising fuel consumption and 10 aspects of automobile
design and performance for 32 automobiles (1973–74 models). Source: Henderson
and Velleman (1981), Building multiple regression models interactively.
 Biometrics, 37, 391–411.")
```

Let's see what this did.

```{r}
attr(mt2, "frame.lab") # check for attribute

get_frame_lab(mt2) # return frame.lab alongside data.frame name as a data.frame

get_frame_lab(mt2)$frame.lab
```

## Add NAME Labels
Now, let's create variable name labels, using named character vector syntax

```{r}
names_labs_vec <- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)
```

Now, we will assign these variable NAME labels

```{r}
mt2 <- add_name_labs(mt2,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)
```

Here is an alternative syntax (same end state)

```{r}
mt2 <- add_name_labs(mt2,
  name.labs = c(
    "mpg" = "Miles/(US) gallon",
    "cyl" = "Number of cylinders",
    "disp" = "Displacement (cu.in.)",
    "hp" = "Gross horsepower",
    "drat" = "Rear axle ratio",
    "wt" = "Weight (1000 lbs)",
    "qsec" = "1/4 mile time",
    "vs" = "Engine (0 = V-shaped, 1 = straight)",
    "am" = "Transmission (0 = automatic, 1 = manual)",
    "gear" = "Number of forward gears",
    "carb" = "Number of carburetors"
  )
)
```

We can replace individual variable name labels, keeping the others as they were.

```{r}
mt2 <- add_name_labs(mt2,
  name.labs = c(
    "disp" = toupper("UH OH!"),
    "mpg" = toupper("i, said, uh oh!!")
  )
)
```
Let's see what this did

```{r}
get_name_labs(mt2)

get_name_labs(mt2, var = c("disp", "mpg"))
```

Enough shenanigans. Let's fix them.

```{r}
mt2 <- add_name_labs(mt2,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

get_name_labs(mt2)
```

That's better.

We can swap out variable name labels for variable names:

```{r}
mt2 <- use_name_labs(mt2)
```

The result is verbose!

```{r}
head(mt2[c(1, 2)])
```

Now, let's revert to our old names.

```{r}
mt2 <- use_var_names(mt2)
head(mt2[c(1, 2)])
```

We can use `get_name_labs` and copy-and-paste to work with these. 

```{r}
mt2 <- use_name_labs(mt2)
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2)
lm(mpg ~ cyl, data = use_var_names(mt2))
```

Turn them back off

```{r}
mt2 <- use_var_names(mt2)
```

## Add ONE-TO-ONE VALUE labels
Now, let's add VALUE labels. Conventional value labels are intended for binary, 
nominal (categorical / multinomial), or ordinal variables with limited numbers of 
distinct values (the default is 10 distinct values for a to-be-value-labeled 
variable, but this can be bumped up using the max.unique.vals option). 

For a given variable, each distinct  value label must have a one-to-one mapping 
with a distinct value of the variable (i.e., no two values can share the same 
label, and no two labels can be applied to the same value). We'll relax this 
constraint in a moment.

```{r}
mt2 <- add_val_labs(
  data = mt2,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

mt2 <- add_val_labs(
  data = mt2,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)
```

The variable argument can be unquoted if we use `add_val1`.

Note that the second argument to `add_val_labs` is vars, while second argument 
to `add_val1` is var.

```{r}
mt2 <- add_val1(
  data = mt2,
  var = cyl, ### note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)
```

There's no law against adding not-yet-needed value labels

```{r}
mt2 <- add_val_labs(
  data = mt2,
  vars = "am",
  vals = c(99),
  labs = c("friend")
)

get_name_labs(mt2)

get_val_labs(mt2)
```

## Add NUMERICAL RANGE labels
Now, let's add numerical value range labels, using `add_quant_labs()`. Whereas
conventional value labels -- such as those added using `add_val_labs()` -- 
enforce a strict one-to-one relationship between a given label and a distinct 
value of a variable, numerical range labels allow one to apply a single label to 
an entire range of numerical values, such as applying the label "q025" to any 
value that is at or below the first quartile of a data.frame.

Here, we'll label the five quintiles of variable "mpg". For each distinct 
quintile label, the highest value of "mpg" that falls within that value range
will be recorded and will be returned by `get_val_labs()` and used by 
`use_val_labs()` to overlay range labels onto values falling within each 
numerical range.

```{r}
# for "disp", add numerical range labels based on quantiles (here, quintiles)
mt2 <- add_quant_labs(data = mt2, vars = "disp", qtiles = 5)

head(use_val_labs(mt2), 4)
```

`add_quant_labs()` also allows on to supply arbitrary literal value thresholds 
as the basis for numerical range labels. We will demonstrate this using 
`add_quant1()`, which is to `add_quant_labs()` as `add_val1()` is to 
`add_val_labs()`. Like `add_val1()`, `add_quant1()` allows one to apply apply 
labels to a single, unquoted variable. 

In this example, we will add numerical range labels to var "mpg," based on 
"pretty" thresholds. 

```{r}
# bound bins using range of "mpg" vals
mpg_bins <- pretty(range(mt2$mpg, na.rm = TRUE))
mpg_bins

mt2 <- add_quant1(
  data = mt2,
  var = mpg,
  vals = mpg_bins
) # assign labels using our "pretty" thresholds

head(use_val_labs(mt2), 4)
```

Note that the vals option is available within `add_quant_labs()` as well, just 
as the qtiles option is available within `add_quant1()`. 

## Add MANY-TO-ONE VALUE Labels
While `add_val_labs()` enforces a strict one-to-one mapping of value labels to 
values, we can relax this constraint using `add_m1_lab()`. "m1" is shorthand for
"many to one". Let's try it with the "gear" variable, where we'll apply a single
label to values of 4 or 5.

```{r}
mt2 <- add_m1_lab(
  data = mt2,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)
```

## Preserve and Restore labelr Attributes
Certain R functions and operations destroy data.frame attributes -- and labelr
labels are data.frame attributes. We can back back up and restore our labels
using `get_all_lab_atts()` and `add_lab_atts()`.

First, let's back up our labels by assigning them to a stand-alone object.

```{r}
zlab.mt2 <- get_all_lab_atts(mt2)
```

Now, let's remove them ourselves, simulating what might happen if some other R 
function removed them.

```{r}
mt2 <- strip_labs(mt2) # remove all labels

get_all_lab_atts(mt2) # they're gone
```

Now, let's restore them.

```{r}
mt2 <- add_lab_atts(mt2, zlab.mt2)
get_all_lab_atts(mt2)
```

## A |> Pipe-based Workflow
Let's use mtcars to illustrate a pipe-based, value-labeling flow with `add_val1()` 

```{r}
mpg_bins <- pretty(range(mtcars$mpg, na.rm = TRUE))

mt_pipe <- mtcars |>
  add_quant1(mpg, vals = mpg_bins) |>
  add_val1(am,
    vals = c(0, 1),
    labs = c("automatic", "manual")
  ) |>
  add_val1(cyl,
    vals = c(4, 6, 8),
    labs = c("four-cyl", "six-cyl", "eight-cyl")
  ) |>
  add1m1(gear,
    vals = 4:5,
    lab = c("4+")
  )
```

Note, we could've used `add_val_labs()` (instead of `add_val1()`), 
`add_quant_labs()` (instead of `add_quant1()`), and `add_m1_lab()` 
(instead of `add1m1()`), in the foregoing pipe operations, but we'd have had to 
quote the variables names in the calls.

## Show Select Rows
```{r}
head(mt_pipe, 5) # Base R function utils::head()

headl(mt_pipe, 5) # labelr function headl() (note the "l")

tail(mt_pipe, 5) # Base R function utils::tail()

taill(mt_pipe, 5) # labelr function taill() (note the "l")

car::some(mt_pipe, 5) # car package function car::some()

somel(mt_pipe, 5, seed = 1837) # labelr function somel() (note the "l")
```

Note that `some()` and `somel()` will not return the same random rows.

## Add Value Label Columns
```{r}
mt_labs <- add_lab_cols(mt_pipe)

head(mt_labs)

head(mt_labs[c("am", "am_lab", "mpg", "mpg_lab")])
```

## "Filter Values Using Labels" with `flab()` 
```{r}
head(mt_pipe)

mt_filt <- flab(mt_pipe, am == "automatic" & mpg %in% c("<=20", "<=25"))

head(mt_filt)
```
