---
title: "Aliases for Common labelr Functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Aliases for Common labelr Functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "### >"
)
```
## Aliases
For "power users" who want to save keystrokes, labelr offers "alias" variants of
several commands. More concise and more cryptic, these will come in handy if you
find yourself re-typing the same commands at the console. 

This vignette is a duplicate of the **Using Labels with Popular R Commands** 
vignette that introduces/substitutes the alias functions for the more interpretable
but more cumbersome long-form commands.

## Summary of Alias Functions and Longer-form Counterparts

* `avl` is an alias for `add_val_labs` 

* `avl1` is an alias for `add_val1` 

* `dvl` is an alias for `drop_val_labs` 

* `dvl1` is an alias for `drop_val1` 

* `aql` is an alias for `add_quant_labs`  

* `aq1` is an alias for `add_quant1` 

* `am1l` is an alias for `add_m1_lab` 

* `gvl` is an alias for `get_val_labs` 

* `uvl` is an alias for `use_val_labs` 

* `wvl` is an alias for `with_val_labs` 

* `anl` is an alias for `add_name_labs` 

* `gnl` is an alias for `get_name_labs` 

* `dnl` is an alias for `drop_name_labs` 

* `unl` is an alias for `use_name_labs` 

* `uvn` is an alias for `use_var_names` 

* `wnl` is an alias for `with_name_labs` 

* `wbl` is an alias for `with_both_labs` 

* `afl` is an alias for `afls` 

* `gfl` is an alias for `get_frame_labs` 

## What Are Labels For?
labelr allows you to label Base R data.frames and then use those labels in a few
different ways, according to your needs. These include: producing basic label 
look-up tables, swapping out values for labels (be careful with this!), augmenting 
a data.frame by providing a labels-as-values column for each labeled variable, and 
letting you temporarily swap in labels for values in descriptive and exploratory 
analyses. Other vignettes cover most of these topics. Here, we will briefly 
illustrate just a few of the "letting you temporarily..." possibilities.

## First things first - Let's Label Our Data Frame
We'll use the popular Motor Trend Cars (mtcars) data.frame. We'll start by loading
labelr, copying mtcars to new data.frame called df, adding variable name labels, 
then adding variable value labels. Then we'll show a few ways to use labels (mostly
value labels) with some non-labelr R commands (mostly Base R).

## Load labelr
Let's load labelr. 

```{r setup}
library(labelr)
```
## Copy mtcars
Create df (a copy of mtcars):
```{r}
df <- mtcars
```

## Add a FRAME Label
Let's add a "frame label," which describes the data.frame overall.
```{r}
mt2 <- afl(mtcars, frame.lab = "Data extracted from the 1974 Motor
Trend US magazine, comprising fuel consumption and 10 aspects of automobile
design and performance for 32 automobiles (1973–74 models). Source: Henderson
and Velleman (1981), Building multiple regression models interactively.
 Biometrics, 37, 391–411.")
```
**Reminder: `afl` is a simple alias for `add_frame_labs`.**


Let's see what this did.
```{r}
attr(mt2, "frame.lab") # check for attribute

gfl(mt2) # return frame.lab alongside data.frame name as a data.frame

gfl(mt2)$frame.lab
```

**Reminder: `gfl` is a simple alias for `get_frame_labs`.**


## Create and Assign NAME Labels
Now, we'll create **name** labels.
```{r}
names_labs_vec <- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)
```

Let's assign these name labels to df, using `anl()`.

**Reminder: `anl` is a simple alias for `add_name_labs`.**

```{r}
df <- anl(df,
  name.labs = names_labs_vec
)
```

## Assign Value Labels

Now, we will assign **VALUE** labels to select variables.

**Reminder: `avl1` is a simple alias for `add_val1`.**

```{r}
df <- df |>
  avl1(am,
    vals = c(0, 1),
    labs = c("automatic", "manual")
  ) |>
  avl1(cyl,
    vals = c(4, 6, 8),
    labs = c("four-cyl", "six-cyl", "eight-cyl")
  ) |>
  avl1(gear,
    vals = 3:5,
    labs = c("3-speed", "4-speed", "5-speed")
  ) |>
  avl1(carb,
    vals = c(1, 2, 3, 4, 6, 8),
    labs = c(
      "1-carb", "2-carbs", "3-carbs",
      "4-carbs", "6-carbs", "8-carbs"
    )
  )
```
Note, we could've used `add_val_labs()` (or its alias `avl`) in the preceding pipe
workflow, but we'd have had to quote the variables names in the calls.

## Where Does This Leave Us?

mtcars remains value label-less:
```{r}
gvl(mtcars)
```

Not so for df. It now has value labels:
```{r}
gvl(df)
```

**Reminder: `gvl` is a simple alias for `get_val_labs`.**


## Use the Labels

Now, we can use the value or name labels when and if it illuminates things. There 
is a trade-off between the plain language interpretability of labels and the 
concision of values. Many label use cases that are possible in principle will be
dubious in practice. This will be a matter of judgment and personal taste.


**Reminder: `uvl` is a simple alias for `use_val_labs`.**

### Grouped Statistics with `collapse::qsu()`
`use_val_labs` converts labeled variables to character variables, which
gives us more interpretable (albeit more verbose) output. We can combine this 
functionality with the `qsu()` function from the collapse package to calculate
grouped statistics, where the value labels define the groups. Note how 0 and 1
become "automatic" and "manual" when df is wrapped in `uvl()`.

```{r}
# with labels "off" (i.e., using regular values of "am" as by var)
by_trans_val <- collapse::qsu(df, cols = c("mpg", "disp"), by = ~am)
by_trans_val

# with labels "on" (i.e., using labels, thanks to `use_val_labs()`)
by_trans_lab <- collapse::qsu(uvl(df), cols = c("mpg", "disp"), by = ~am)
by_trans_lab
```
### `xtabs()` 
Likewise, `use_val_labs` gives us more interpretable output in this application 
of `xtabs()`

```{r}
xtabs(~am, data = df)

xtabs(~am, data = uvl(df))
```
See also `tabl()`.

### `t.test()`
`uvl` (or `use_val_labs`) converts labeled variables to character variables, which
gives us more interpretable output in this application of `t.test()` if we focus
on the **"mean in..."** text of the output.

```{r}
t.test(mpg ~ am, data = df)

t.test(mpg ~ am, data = uvl(df)) # value labels "on"; same as `use_val_labs`
```

### `lm()`
`uvl` (or `use_val_labs`) converts labeled variables to character variables, then 
`lm()` converts them to factors on the fly.

```{r}
# this
lm(mpg ~ am + cyl + gear, data = df) # equivalent to mtcars, labels "off"

# is the same as this:
lm(mpg ~ am + cyl + gear, data = mtcars) # mtcars is same as our df

# if we were to coerce our predictors to factors, we would get this
lm(mpg ~ as.factor(am) + as.factor(cyl) + as.factor(gear), data = df)

# value labels "on" turns these to character; `lm()` treats them as factor
lm(mpg ~ am + cyl + gear, data = uvl(df)) # `uvl` is alias for `use_val_labs`
```

### collapse package's `qsu()` command and `unl()`
What about variable **NAME** labels? 
<br>
<br>
These tend to be rather verbose, so, worthwhile applications may be more limited.
<br>
<br>
But here is one that could be helpful, thanks to an assist from the collapse package.
<br>
<br>
**Reminder: `unl` is a simple alias for `use_name_labs`.**
<br>

`collapse::qsu()` (from collapse package) with df vs. df wrapped in `unl()`

```{r}
collapse::qsu(df)

collapse::qsu(unl(df))
```
