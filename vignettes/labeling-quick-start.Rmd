---
title: "Labelr - A Selective Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Labelr - A Selective Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "### >",
  fig.width = 7,
  fig.height = 4.7
)
```
## A Whirlwind Tour
This vignette provides an ad hoc introduction to a smattering of labelr 
functionalities and uses cases. Other brief vignettes cover additional issues and 
applications, offering a mix of new material and expanded treatments or excerpts 
from this vignette.

## Types of Labels
labelr supports the creation and use of a few different types of labels in the 
context of R data.frames. Specifically, labelr supports three core types of 
data.frame labels, the last of which comes in three flavors:

1. **Frame labels** - Each data.frame may be given a single "frame label" of 500 
  characters or fewer, which may describe key general features or characteristics
  of the data set (e.g., source, date produced or published, high-level 
  contents). 
  
2. **Name labels** - Each variable may be given exactly one name label, which is 
  an extended variable name or brief description of the variable. For example, 
  if a variable called "st_b" refers to a survey respondent's state of birth, 
  then a sensible and useful name label might be "State of Birth". Or, if a 
  variable called "trust1" consisted of responses to the consumer survey 
  question, "How much do you trust BBC news to give you unbiased information?," 
  a sensible name label might be "BBC Trust." As such, name labels are 
  comparable to what Stata and SAS call "variable labels."

3. **Value labels** - labelr offers three kinds of value labels. 
    * *One-to-one labels* - The canonical value-labeling use case entails mapping 
     distinct values of a variable to distinct labels in a one-to-one fashion, so
     that each value label uniquely identifies a substantive value. For instance, 
     an administrative data set might assign the integers 1-7 to seven distinct 
     racial/ethnic groups, and value labels would be critical in mapping those 
     numbers to socially substantive racial/ethnic category concepts (e.g., 
     Which number corresponds to the "Asian American?"). 
    
    * *Many-to-one labels* - In an alternative use case, value labels may serve to
     distill or "bucket" distinct variable values in a way that deliberately 
     "throws away" information for purposes of simplification. For example, one 
     may wish to give the single label "Agree" to the responses "Very Strongly 
     Agree," "Strongly Agree," and "Agree." Or one may wish to differentiate 
     self-identified "White" respondents from "People of Color," applying the 
     latter value label to all categories other than "White."
    
    * *Numerical range labels* - Finally, one may wish to carve a numerical 
     variable into an ordinal or qualitative range, such as dichotomizing a
     variable or dividing it into quantiles. Numerical range labels support 
     one-to-many assignment of a single value label to a range of numerical 
     values for a given variable.


## Core Use Cases and Capabilities
More specifically, labelr functions support the following actions:

1. Assigning variable value labels, name labels, and a frame label to data.frames 
   and modifying those labels thereafter.
   
2. Generating and accessing simple look-up table-style data.frames to inform or
   remind you about a given variable's name label, frame label, or the value 
   labels that correspond to its unique values (i.e., Which racial/ethnic 
   identity category label corresponds to a value of 3?).
   
3. Swapping out variable names for variable labels and back again.

4. Replacing variables' values with their corresponding labels.

5. Augmenting a data.frame by adding columns of variable labels that can exist
   alongside the column of variable values.
   
6. Engaging in base::subset-like row-filtering, using value labels to guide the
   filtering without converting values to labels in the returned data.frame.
   
7. Tabulating value frequencies that can be expressed in terms of raw values or
   value labels-- again, without modifying or converting the raw data.frame 
   values.
   
8. Preserving and restoring a data.frame's labelr labels in the event that 
   some unsupported R operation destroys them.
   
9. Applying a single value-labeling scheme to many variables at once (for 
   example, assigning the same set of Likert-scale labels ("Strongly Agree," 
   etc.) to all variables that share a common variable name character substring.

## Load the Package
Let's start by loading labelr.

```{r setup}
library(labelr)
```

## Demonstration 1 - (Fake) Demographic Data
Let's create a fake "demographic" data.frame, apply labels to it, and do some
things with those labels.

### Make toy demographic data.frame
This function (included with labelr) creates fake "demographic" data intended
for use in exploring/demonstrating labelr functionality.

```{r}
set.seed(555)
df <- make_demo_data(n = 1000)
```

### Add a variable "frame label" using `add_frame_lab()` 
We'll start our labeling session by providing a fittingly fictional high-level 
description of this fictional data set.

```{r}
df <- add_frame_lab(df, frame.lab = "Demographic and reaction time test score
                    records collected by Royal Statistical Agency of
                    Fictionaslaviaca. Data fictionally collected in the year
                    1987. As published in A. Smithee (1988). Some Fictional Data
                    for Your Amusement. Mad Magazine, 10(1), 1-24.")


get_frame_lab(df)
```

### Add variable name labels using `add_name_labs()` 
Now, let's add (some fairly trivial) variable NAME labels

```{r}
df <- add_name_labs(df, name.labs = c(
  "age" = "Age in years",
  "raceth" = "Racial/ethnic identity group category",
  "gender" = "Gender identity",
  "edu" = "Highest education level attained",
  "x1" = "Space Invaders reaction time test scores",
  "x2" = "Galaga reaction time test scores"
))
```

Even if we do nothing else with these name labels, we can access or manipulate a
simple lookup table as needed.

```{r}
get_name_labs(df)
```

### Add value labels using `add_val_labs()`
Let's add one-to-one value labels for variable "raceth". Note: max.unique.vals 
sets an upper limit on the number of unique values a variable may have be 
considered "value-label-able." labelr sets an overall upper limit of 5000 unique 
value labels permissible per variable. 

```{r}
df <- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c(
    "White", "Black", "Hispanic",
    "Asian", "AIAN", "Multi", "Other"
  ),
  max.unique.vals = 10
)
```

### Add value labels using `add_val1()`
Let's add value labels for variable "gender." Function `add_val1` allows you to 
supply the variable name unquoted, provided you are value-labeling only one
variable. (Not evident from the above, but add_val_labs supports labeling 
multiple variables at once).

```{r}
df <- add_val1(
  data = df, gender, vals = c(0, 1, 2),
  labs = c("Male", "Female", "Other"), max.unique.vals = 10
)
```

Once again, we can create a lookup table with the labels-to-values mappings.

```{r}
get_val_labs(df)
```

### Add NUMERICAL RANGE Labels Using `add_quant_labs()`
Traditionally, value labels are intended for categorical variables, such as 
binary, nominal, or (integer) ordinal variables with limited numbers of distinct 
categories. Further, value labels that are added using `add_val_labs` 
(or `add_val1`) are constrained to map one-to-one to distinct values: Any given 
value label can map to only one distinct value and vice versa.

If you wish to apply a label to a range of values of a numerical variable,
such as labeling each value according to the quintile or decile to which it 
belongs, you can use `add_quant_labs()` (or `add_quant1`) to do so.

Here, we will use `add_quant_labs` to apply quintile range labels to all 
variables of df that have an "x" in their names (i.e., vars "x1" and "x2")

```{r}
df_temp <- add_quant_labs(data = df, vars = "x", qtiles = 5, partial = TRUE)
```

As `add_quant_labs` adds those numerical range labels, the console output shows
the actual quintile value of the supplied variable (here, "x1" and "x2") that 
corresponds to each quintile (range) label. Any value at or below that value 
(and above the next-lowest quintile value) is assigned that quintile label.

We can use the same function to assign arbitrary, user-specified range labels. 
Here, we assign labels that differentiate values of "x1" and "x2" that are at or
below 100 from values that are at or below 150.

```{r}
df_temp <- add_quant_labs(
  data = df_temp, vars = "x", vals = c(100, 150),
  partial = TRUE
)
```

Having demonstrated the basic functionality, let's use `add_quant1` to apply 
decile range labeling to variable "x1" only. This function only accepts one 
variable, but its name can be supplied unquoted.

```{r}
df <- add_quant1(df, x1, qtiles = 5)
```

We'll preserve the "x1" range labels going forward, keeping "x2" unlabeled.

### Add MANY-TO-ONE VALUE Labels Using `add_m1_lab()`
If you wish to apply a single label to multiple distinct values, this can be
done through successive calls to `add_m1_lab()` (or `add1m1()`, if working with
a single variable). Here "m1" is shorthand for "many to one." 

Note that each call to `add_m1_lab()` applies a single value label, so,  
multiple calls are needed to apply multiple labels. Here, we illustrate this, 
applying the label "Some College+" to values 3, 4, or 5 of the variable "edu", 
then applying other distinct labels to values 1 and 2, respectively.

```{r}
df <- add_m1_lab(df, "edu", vals = c(3:5), lab = "Some College+")

df <- add_m1_lab(df, "edu", vals = 1, lab = "Not HS Grad")

df <- add_m1_lab(df, "edu", vals = 2, lab = "HSG, No College")

get_val_labs(df)
```

### Where Do We Stand?
All of this is nice, but have we really accomplished anything? A casual view of 
the data.frame suggests that it has not changed from its initial state. 

```{r}
head(df)
```

But labeling has introduced unobtrusive but important features for us to use. 
Let's take a look.

### Swap out values for labels with `use_val_labs()` and `with_*()` commands
Now that our data.frame is labeled, we can overlay value labels -- that is, swap 
out values for labels. We might do this temporarily, to visualize the labels.

```{r}
head(use_val_labs(df), 5)
```

Or we could do something more "permanent," such as assigning the result to a new 
object that will replace our value-labeled columns. There is no direct way to 
"undo" a call to `use_val_labs()`, so, it is safest to assign the result to a 
new object (or try `add_lab_cols()`, discusse momentarily).

```{r}
df_labd <- use_val_labs(df)
```

Similarly, we can use with()-like non-standard evaluation to overlay labels, 
which is helpful in a few limited cases. Note how `with_val_labs` behaves below.
```{r}
with(df, table(gender, raceth))

with_val_labs(df, table(gender, raceth))

wvl(df, table(gender, raceth)) # wvl() is an more compact alias

with(use_val_labs(df), table(gender, raceth))
```

We also have options for overlaying / swapping out variable NAME labels for 
actual variable column names, as we'll see below.

### Show First, Last, or Random Rows with Value Labels Overlaid
Base R includes the `head()` and `tail()` functions, which allow you to show the
first n or last n rows of a data.frame. The car package offers a similar function
called `some()`, which allows you to show a random n rows of a data.frame.

labelr provides versions of these functions that will display value labels in 
place of values (akin to `use_val_labs()`). Below, each of the three standard
functions is demonstrated, followed by its labelr counterpart.

```{r}
head(df, 5) # Base R function utils::head()

headl(df, 5) # labelr function headl() (note the "l")

tail(df, 5) # Base R function utils::tail()

taill(df, 5) # labelr function taill() (note the "l")

set.seed(293)
car::some(df, 5) # car package function car::some()

set.seed(293)
somel(df, 5) # labelr function somel() (note the "l")
```
Note that `some()` and `somel()` will not return the same random rows, even with 
the same seed.

### Add value labels back to the data.frame with `add_lab_cols()`
Whereas `use_val_labs()` replaces value-labeled variable values with their 
labels, we do not strictly need to choose between values and labels. We can 
preserve all existing variables, including the value-labeled ones, while adding 
an additional labels-as-values column for each value-labeled column. Easier done
than said, perhaps. Take a look:

```{r}
df_plus_labs <- add_lab_cols(df)

head(df_plus_labs)

head(df_plus_labs[c("gender", "gender_lab", "raceth", "raceth_lab")])
```

### "Filter values using labels" with `flab()` 
We can filter a value-labeled data.frame on the basis for value labels, 
returning the subsetted data.frame with the labels still in the background. 
For example, here we use the more semantically meaningful value labels to 
filter our data.frame.

```{r}
head(df)

df1 <- flab(df, raceth == "Asian" & gender == "Female")

head(df1, 5)

head(use_val_labs(df1), 5)
```

### "Subset using labels" with `slab()` 
As with `base::subset()`, we can also limit which columns we return.

```{r}
head(slab(df, raceth == "Black" & gender == "Male", gender, raceth), 10)
```

### Tabulate frequencies with `tabl()`
labelr's `tabl()` function supports count tabulations with labels turned "on"
or "off" and offers some other functionalities. For example, tables can be 
generated... 

...in terms of values
```{r}
head(tabl(df), 20)
```
...or in terms of labels
```{r}
head(tabl(df, labs.on = TRUE), 20)
```
...in proportions
```{r}
head(tabl(df, labs.on = TRUE, prop.digits = 3), 20)
```
...cross-tab style
```{r}
head(tabl(df, labs.on = TRUE, wide.col = "gender"), 20)
```

### Use with Other Packages
`uvl()` is a more compact alias for `use_val_labs()`. We can wrap it around our
data.frame and pass to other functions, which may yield more interpretable output.
Here is an illustration that passes a `uvl()` -wrapped data.frame to the `qsu()`
function of the collapse package. 

```{r}
# `collapse::qsu()`
# with labels "off" (i.e., using regular values of "raceth" as by var)
by_demog_val <- collapse::qsu(df, cols = c("x2"), by = ~raceth)
by_demog_val

# with labels "on" (i.e., using labels, thanks to `uvl()`)
by_demog_lab <- collapse::qsu(uvl(df), cols = c("x2"), by = ~raceth)
by_demog_lab
```
Note that the second call would achieve the same result if we used `use_val_labs()`,
but `uvl()` is a bit more compact.

## Demonstration 2 - (Fake) Likert-Style Survey Data
`add_val_labs` "vars" arg will do partial matching if partial = TRUE.
In this case, we catch all vars with "x" in their name

### Make fake likert data to explore labelr
`make_likert_data` is another labelr-provided function.

```{r}
set.seed(272)
dflik <- make_likert_data(scale = 1:7)
head(dflik)
```
Put the variables we wish to label and the labels to use in stand-alone vectors, 
which we will supply to `add_val_labs` in a moment.

```{r}
vals2label <- 1:7
labs2use <- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)
```

### Apply the same labeling scheme to many variables using `add_val_labs()`
Now, associate/apply the value labels to all vars with "x" in name and var "y3."
Note: partial = TRUE.

```{r}
dflik <- add_val_labs(
  data = dflik, vars = c("x", "y3"), ###  note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)
```
Compare dflik with value labels present but "off" to labels "on."

Present but "off."
```{r}
head(dflik)
```
Let's "turn on" (use) these value labels.
```{r}
lik1 <- use_val_labs(dflik)
head(lik1)
```

All variables with "x" in their name (and "y3") got the labels! This can't be
reversed (without re-running our preceding code, at least!), so, we saved the
result of `use_val_labs` to a different object (lik1). 

### Discard value labels we don't want using `drop_val_labs`
Let's demo `drop_val_labs` while we're here.

```{r}
dfdrop <- drop_val_labs(dflik,
  c("x2", "y3"),
  partial = FALSE
)
```

Our value labels are here, except for variables "x2" and "y3"

```{r}
get_val_labs(dfdrop, "x2")
```

Compare to values for variable "x1" (we did not drop value labels from this one)

```{r}
get_val_labs(dfdrop, "x1")
```

We can also drop value labels from all variables with "x" in their variable names.

```{r}
dfxgone <- drop_val_labs(dflik,
  c("x"),
  partial = TRUE
)
```

We still have value labels for "y3", but all the "x" var value labels are gone.
```{r}
get_val_labs(dfxgone)
```

## Demonstration 3 - Motor Trend Cars (mtcars)
mtcars frequently appears in R examples and demonstrations, so, let's use
it to lock in our understanding of labelr.
<br>

We'll start by assigning mtcars to a new data.frame that we'll call mt2.

```{r}
mt2 <- mtcars
```

First, let's inject a missing row into the data, to keep things interesting

```{r}
mt2[1, 1:11] <- NA
rownames(mt2)[1] <- "Missing Car"
```

Let's add a "frame label," which describes the data.frame overall.

```{r}
mt2 <- add_frame_lab(mt2, frame.lab = "Data extracted from the 1974 Motor
Trend US magazine, comprising fuel consumption and 10 aspects of automobile
design and performance for 32 automobiles (1973–74 models). Source: Henderson
and Velleman (1981), Building multiple regression models interactively.
 Biometrics, 37, 391–411.")
```

Let's see what this did.

```{r}
attr(mt2, "frame.lab") # check for attribute

get_frame_lab(mt2) # return frame.lab alongside data.frame name as a data.frame

get_frame_lab(mt2)$frame.lab
```

Let's create variable name labels, using named character vector syntax

```{r}
names_labs_vec <- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)
```

Now, we will assign these variable NAME labels

```{r}
mt2 <- add_name_labs(mt2,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)
```

Here is an alternative syntax (same end state)

```{r}
mt2 <- add_name_labs(mt2,
  name.labs = c(
    "mpg" = "Miles/(US) gallon",
    "cyl" = "Number of cylinders",
    "disp" = "Displacement (cu.in.)",
    "hp" = "Gross horsepower",
    "drat" = "Rear axle ratio",
    "wt" = "Weight (1000 lbs)",
    "qsec" = "1/4 mile time",
    "vs" = "Engine (0 = V-shaped, 1 = straight)",
    "am" = "Transmission (0 = automatic, 1 = manual)",
    "gear" = "Number of forward gears",
    "carb" = "Number of carburetors"
  )
)
```

### Update pre-existing name labels with `add_name_labs()`
We can replace individual variable name labels, keeping the others as they were.

```{r}
mt2 <- add_name_labs(mt2,
  name.labs = c(
    "disp" = toupper("UH OH!"),
    "mpg" = toupper("i, said, uh oh!!")
  )
)
```

Let's see what this did

```{r}
get_name_labs(mt2)

get_name_labs(mt2, var = c("disp", "mpg"))
```

Enough shenanigans. Let's fix them.

```{r}
mt2 <- add_name_labs(mt2,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

get_name_labs(mt2)
```

That's better.

### Switch variable names and name labels using `use_name_labs()`
We can swap out variable name labels for variable names

```{r}
mt2 <- use_name_labs(mt2)
```

The result is verbose!

```{r}
head(mt2[c(1, 2)])
```

### Switch back to variable names using `use_var_names()`
Let's revert to our old names.

```{r}
mt2 <- use_var_names(mt2)
head(mt2[c(1, 2)])
```

### Work with name labels for more descriptive (and verbose!) calls and output
We can use `get_name_labs` and copy-and-paste to work with these. 

```{r}
mt2 <- use_name_labs(mt2)
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2)
lm(mpg ~ cyl, data = use_var_names(mt2))
```

Turn them back off

```{r}
mt2 <- use_var_names(mt2)
```

### Interactively swap in name labels for column names 
We can use `with_name_labs()` (or the more compact alias `wnl()`) to display 
name labels in place of column labels in fairly flexible ways.

```{r}
# verify that we still have name labels
get_name_labs(mt2)

# demo wnl() (note that with_name_labs() will achieve same result)
wnl(mt2, t.test(mpg ~ am))

wnl(mt2, lm(mpg ~ am))

wnl(mt2, summary(mt2))

wnl(mt2, xtabs(~gear))

xtabs(~ mt2$gear) # compare to directly above
```

```{r}
invisible(wnl(mt2, hist(mpg))) # name label, not colname as title

invisible(wnl(mt2, plot(mpg, carb))) # name labels, not colnames, on axes
```

### Add and use variable VALUE labels
Let's add VALUE labels.

```{r}
mt2 <- add_val_labs(
  data = mt2,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

mt2 <- add_val_labs(
  data = mt2,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)
```

The variable argument can be unquoted if we use `add_val1`.
Note that the second argument to `add_val_labs` is vars, while second argument 
to `add_val1` is var.

```{r}
mt2 <- add_val1(
  data = mt2,
  var = cyl, ### note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)
```

### Add and NUMERICAL RANGE value labels
Now, let's add numerical value range labels, using `add_quant_labs()`. 

We'll label the five quintiles of variable "mpg". For each distinct 
quintile label, the highest value of "mpg" that falls within that value range
will be recorded and will be returned by `get_val_labs()` and used by 
`use_val_labs()`.

```{r}
# for "disp", add numerical range labels based on quantiles (here, quintiles)
mt2 <- add_quant_labs(data = mt2, vars = "disp", qtiles = 5)

# for "mpg", add numerical range labels based on "pretty" cuts
# bound bins using range of "mpg" vals
mpg_bins <- pretty(range(mt2$mpg, na.rm = TRUE))
mpg_bins


mt2 <- add_quant_labs(
  data = mt2,
  vars = "mpg",
  vals = mpg_bins
) # assign labels using our "pretty" thresholds

head(use_val_labs(mt2), 4)
```

### Add MANY-TO-ONE VALUE Labels
Let's demonstrate "m1" ("many to one") value labels with the "gear" variable.

```{r}
mt2 <- add_m1_lab(
  data = mt2,
  vars = "gear",
  vals = 3,
  lab = "3"
)

mt2 <- add_m1_lab(
  data = mt2,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)
```

### Preserve and Restore Labels
Preserve label attributes.

```{r}
zlab.mt2 <- get_all_lab_atts(mt2)
```

Now, remove them.

```{r}
mt2 <- strip_labs(mt2)
get_all_lab_atts(mt2)
```

Now, restore them.

```{r}
mt2 <- add_lab_atts(mt2, zlab.mt2)
get_all_lab_atts(mt2)
```

### Add value labels with a |> pipe-based workflow
Let's try a pipe-based, value-labeling flow with `add_val1()` 

```{r}
mt_pipe <- mtcars |>
  add_val1(am,
    vals = c(0, 1),
    labs = c("automatic", "manual")
  ) |>
  add_val1(cyl,
    vals = c(4, 6, 8),
    labs = c("four-cyl", "six-cyl", "eight-cyl")
  ) |>
  add1m1(gear,
    vals = 3,
    lab = "3"
  ) |>
  add1m1(gear,
    vals = c(4, 5),
    lab = c("4+")
  ) |>
  add_val1(carb,
    vals = c(1, 2, 3, 4, 6, 8),
    labs = c(
      "1-carb", "2-carbs", "3-carbs",
      "4-carbs", "6-carbs", "8-carbs"
    )
  ) |>
  add_quant1(mpg,
    qtiles = 4
  )
```

Note, we could've used `add_val_labs()` (instead of `add_val1()`), `add_m1_lab()` 
(instead of `add1m1()`), and `add_quant_labs()` (instead of `add_quant1()`) in 
the foregoing pipe operations, but we'd have had to quote the variables names in 
the calls.

### Show Select Rows
```{r}
head(mt_pipe, 5) # Base R function utils::head()

headl(mt_pipe, 5) # labelr function headl() (note the "l")

tail(mt_pipe, 5) # Base R function utils::tail()

taill(mt_pipe, 5) # labelr function taill() (note the "l")

set.seed(1837)
car::some(mt_pipe, 5) # car package function car::some()

set.seed(1837)
somel(mt_pipe, 5) # labelr function somel() (note the "l")
```

Note that `some()` and `somel()` will not return the same random rows, even with 
the same seed.
