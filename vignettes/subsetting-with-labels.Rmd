---
title: "Subsetting with Labels"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Subsetting with Labels}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "### >"
)
```
First, let's load labelr.

```{r setup}
library(labelr)
```

## Overview
labelr supports the use of value labels in subsetting/filtering data.frames,
through two functions, `flab()` ("filter using labels") and `slab()` ("subset 
using labels"). These functions allow us to use value label meta-data that is
"hidden" in the attributes of our data.frame to manipulate that data.frame. 
After all, one of the key purposes of value labels is to make ambiguous data 
values more semantically meaningful and actionable (think gender=="F" vs. 
gender==2); so, being able to leverage these labels for filtering purposes would
seem like an attractive feature.

## Our Data
Let's use labelr's `make_demo_data()` command to create a fake "demographic" 
data.frame that we'll subset using `flab()` and `slab()`.

```{r}
set.seed(555)
df <- make_demo_data(n = 50)

nrow(df)

head(df)
```
Note that the funky row names are here to help you get a fix on the stable or
changing state of literal rows as they move through the workflow.

```{r}
head(rownames(df))
```

### Let's add value labels using add_val1
Let's use R's native pipe to add value labels for variables "raceth" and "gender"
and assign the result to a new data.frame called df_lab.

```{r}
df_lab <- df |>
  add_val1(raceth,
    vals = c(1:7),
    labs = c(
      "White", "Black", "Latino",
      "Asian", "AIAN", "Multi", "Other"
    )
  ) |>
  add_val1(gender,
    vals = c(0, 1, 2),
    labs = c("M", "F", "O")
  )
```

### Pre- vs. Post-labeling
First, to get anchored, note that these two data.frames look and act much the 
same. Let's demonstrate.

They have the same number of rows, columns, and variable classes.

```{r}
sapply(df, class)

sapply(df_lab, class)

dim(df)

dim(df_lab)
```

They look the same and are numerically the same.

```{r}
head(df, 4)

head(df_lab, 4)

table(df$gender)

table(df_lab$gender)

cor(df$age, df$gender)

cor(df_lab$age, df_lab$gender)
```
But our labeled version has something the unlabeled version doesn't: Value 
labels!

```{r}
get_val_labs(df, c("gender", "raceth"))

get_val_labs(df_lab, c("gender", "raceth"))

head(use_val_labs(df_lab), 4)
```

### Conventional Subsetting
There are various subsetting functions out there, including the popular dplyr
suite. For now, we'll stick with Base R's `subset()` function to show
conventional subsetting, which will anchor us. Here, we subset our labeled
and unlabeled data.frames with the same syntax, to show their functional
equivalence.

Here, we'll filter gender values of 1 and return only the raceth and gender variables.

```{r}
head(subset(df, gender == 1, c(raceth, gender)))

head(subset(df_lab, gender == 1, c(raceth, gender)))
```

### Label-based Subsetting
With our labeled data.frame, we can achieve the same thing, using value labels
instead. Let's subset-using-labels, filtering on the label for the variable gender,
selecting (returning) only the raceth and gender columns. We'll wrap this in a call
to `head()` to return only the first 10 observations of the returned data.frame.

```{r}
head(slab(df_lab, gender == "F", raceth, gender), 10)
```

Note that the data.frame returned has the same look and feel as df and df_lab.
We used the label "F" to filter on the variable gender, but this was just an
idiom: the returned values of this column are still numerical zeros and ones.

Note also that, unlike `base::subset()`, `labelr::slab()` does not want us
to use the c() concatenation syntax. We just list our columns, one after the 
other, comma-separated.

If we want to return all columns and simplify things, we can filter-on-labels
using `flab()`. The call is the same as above, except now we use `flab()`, and
we do not specify columns to retain.

```{r}
head(flab(df_lab, gender == "F"), 10)
```
### What about Non-value-labeled Variables?
`slab()` and `flab()` require you to filter using character (quoted) value 
labels for columns / variables that are, in fact, value-labeled. If you run into
a filtering issue, you should call `get_val_labs()` on your data.frame to see
what value labels are associated with each variable/column of your data.frame.

If you want to include non-value-labeled variables in your filtering, you are
free to do so. In this example, we call `flab()`, filtering on gender value labels 
and literal age values (since age is not value-labeled).

```{r}
df_age <- flab(df_lab, gender == "F" & age > 30 & age < 45)

head(df_age[c("gender", "age")])
```

### Preserving Label Attributes - Not All Subsetting Does This!
Something we conveniently ignored above is that `base::subset()` silently 
dropped our value label information in the process of subsetting. That's not 
great! 

```{r}
get_val_labs(df_lab, c("raceth", "gender")) # they're here

df_sub <- subset(df_lab, gender == 1, c(raceth, gender)) # base::subset-ting

head(df_sub, 3) # it worked

get_val_labs(df_sub, c("raceth", "gender")) # but we lost our value labels!
```

`slab()` doesn't suffer from this problem.

```{r}
get_val_labs(df_lab, c("raceth", "gender")) # they're here

df_slab <- slab(df_lab, gender == "F", raceth, gender) # labelr::slab-bing

head(df_slab, 3) # it worked

get_val_labs(df_slab, c("raceth", "gender")) # the labels are intact.
```
### Preserving Label Attributes While Filtering by Values (Not Labels)
But what if we want to retain our label information while filtering in the more 
conventional way -- by values, not labels? We have a few options. 

First, as of this writing, the popular dplyr package retains these attributes.

```{r}
get_val_labs(df_lab, c("raceth", "gender")) # they're here

df_ply <- dplyr::filter(df_lab, gender == 1) # dplyr::filter-ing

df_ply <- dplyr::select(df_ply, gender, raceth) # dplyr::select-ing

head(df_ply, 3) # it worked

get_val_labs(df_ply, c("raceth", "gender")) # the labels are intact.
```

Another option is labelr's `ssubset()` ("safe subset"), which is like `flab()`
in that it retains label attributes (hence, it is "safe" with respect to
label preservation) and like `base::subset()` in that you filter by variable 
values, not labels.

```{r}
get_val_labs(df_lab, c("raceth", "gender")) # they're here

df_ssub <- ssubset(df_lab, gender == 1, gender, raceth) # labelr::ssubset-ting

head(df_ssub, 3) # it worked

get_val_labs(df_ssub, c("raceth", "gender")) # the labels are intact.
```
Labelr offers other "safe" data management functions, which are discussed in 
the documentation. These include safe sorting (`ssort`), safe filtering
(`sfilter`), safely keeping (`sselect`) or dropping (`sdrop`) columns, and
safely subsetting using a more flexible, bracket-like subsetting (`sbrac`) 
idiom. 

The dplyr functions are more flexible, offering various helper functions and
variable-selection idioms that labelr's "safe" data management functions do not.
If you know and like dplyr, its functions may be your best bet, assuming dplyr
still retains labelr attributes the way it does/did at the time of this writing.
The labelr "safe" functions are offered so that labelr can provide a self-
contained solution to protect what it creates without being subject to the 
vicissitudes of external package dependencies. But there's no reason not to play 
around and develop whatever workflow suits you. 

One important caveat to this: labelr subsetting functions will automatically 
update a data.frame's label attributes to account for the dropping or renaming 
of variables -- dropping a variable's name and value labels if the variable 
itself is dropped and updating name and value label associations if the variable
is renamed. In contrast, even when they retain the labelr information they are 
given, non-labelr subsetting functions like dplyr will not update label meta-data 
to synchronize it with the dropping or renaming of variables. labelr offers 
functions like `transfer_labs()` to support in such cases.

