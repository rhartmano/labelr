---
title: "Some Common Value-labeling Pitfalls"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Some Common Value-labeling Pitfalls}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  comment = "### >"
)
```

## Overview
In this vignette, we will briefly -- in an ad hoc, "ride-along" fashion -- 
introduce you to ways that you can run afoul of `add_val_labs` and `add_val1` 
expectations, as well as ways to avoid or mitigate this. Note that these functions
assume you wish to implement one-to-one value-labeling, where each of a variable's
distinct values gets one distinct value label that is exclusive to that value 
(i.e., different values of a given variable cannot share the same value label). 
Other labelr functions (e.g., `add_quant_labs`, `add_m1_lab`) allow for more 
flexible value-labeling (i.e., applying a single label to groups or ranges 
of values). These alternatives receive very limited treatment here but are 
demonstrated in other vignettes.

### Our Data
First, let's load labelr.
```{r}
library(labelr)
```

Now, lets assign the Base R-furnished mtcars (Motor Trend Cars) data.frame to
a new data.frame we'll call mtbad.
```{r}
mtbad <- mtcars
```

## Injecting Irregular Values into Our Data
We will add various irregular values to make things interesting. 
We also will add some supplementary (nonsense) variables.

### Add NA and Other Irregular Values
```{r}
mtbad[1, 1:11] <- NA
rownames(mtbad)[1] <- "Missing Car"
mtbad[2, "am"] <- Inf
mtbad[3, "gear"] <- -Inf
mtbad[5, "carb"] <- NaN
```

### Add a Character Variable
Add a character variable, for demonstration purposes.
```{r}
set.seed(9202)
mtbad$grade <- sample(c("A", "B", "C"), nrow(mtbad), replace = TRUE)
mtbad[4, "grade"] <- NA
mtbad[5, "grade"] <- "NA"
mtbad[6, "grade"] <- "Inf"
```

### Add an Ordered Factor
Make a fake ordered factor that we add to mtbad.
```{r}
set.seed(293)
qrating <- c("AAA", "AA", "A", "BBB", "AA", "BBB", "A")

mtbad$qrat <- sample(qrating, 32, replace = TRUE)
mtbad$qrat <- factor(mtbad$qrat,
  ordered = TRUE,
  levels = c("AAA", "AA", "A", "BBB")
)
```

### Add an Unordered Factor
Make a fake unordered factor to add.
```{r}
color <- c("blue", "black", "green", "other")
mtbad$color <- sample(color, 32, replace = TRUE)
mtbad$color <- factor(mtbad$color, levels = color)
```

See where this leaves us.
```{r}
head(mtbad, 5)
sapply(mtbad, class)
```

## Adding Value Labels
Now, we will (attempt to) add value labels, experiencing some setbacks as we go.

### Starting with No Value Labels
We start out with no value labels.
```{r}
get_val_labs(mtbad)
```

### labelr Will Take Guesses
If we don't explicitly provide labels, labelr will use the values themselves 
(coerced to character) as labels.

```{r}
mtbad <- add_val_labs(
  data = mtbad,
  vars = "am",
  vals = c(0, 1),
  labs = NULL, # note that our labs (labels) argument is NULL
  max.unique.vals = 7
)
```

See what this did.

Note that the "NA" label is a catch-all label automatically applied to 
NA values and other irregular values (e.g., NaN, Inf). More on that in a bit.
```{r}
get_val_labs(mtbad, "am")
```

### We Can Drop Labels
Drop these so we can try again.
This drops all value labels for variable "am" only.
If we wanted to only drop all value labels for all variables, we could do this: 
`drop_val_labs(mtbad)`.

```{r}
mtbad <- drop_val_labs(mtbad, "am")
```

### What If Both vals and labs Are NULL?
Note that, even if both vals AND labs are NULL, `add_val_labs` will attempt
To auto-populate the labs, unless doing so exceeds the max.unique.vals threshold.
```{r}
mtbad <- add_val_labs(
  data = mtbad,
  vars = "am",
  vals = NULL,
  labs = NULL, max.unique.vals = 7
)
```

### Using `add_val1`
Add_val1 works the same way. It is less flexible than `add_val_labs`, but we
can supply a (single) variable to label without quoting the variable.

First, let's drop any current value labels to start fresh.

```{r}
mtbad <- drop_val_labs(mtbad) # This drops all value labels, regardless of var
```

Now, let's use `add_val1()` to add value labels.
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = am, # var arg, not vars; and unquoted col name
  vals = c(0, 1),
  labs = NULL, # if NULL, the labs will be same as the vals
  max.unique.vals = 7
)
```

## Incrementally Adding Value Labels 
We can incrementally update our "gear" value labels.

```{r}
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(3, 4), # first get these two
  labs = c("a", "b")
)

mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(5), # now get this one
  labs = c("c")
)
```

This sort of incremental updating is permitted by `add_val_labs()` and 
`add_val1()`, and it is required for use of `add_m1_labs()` and `add1m1()`, but
it is not permitted when using `add_quant_labs()` or `add_quant1()`: these 
latter commands require all numerical range cutpoints and associated labels to 
be specified in a single call (or that you use the qtiles argument in lieu of 
specifying cutpoints). 
 
## "Contradictory" or Confusing Labels
labelr takes some steps to protect us from implementing dubious labeling 
schemes, like trying to apply one of "gear"'s values as the label for some other 
value (e.g., applying the label "5" to "gear" values that equal 4). 

For example, labelr doesn't like this:
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(3, 4, 5),
  labs = c(5, 3, 4)
)
```

labelr's defensive skills have their limits -- if we're bound to do strange 
things, we can.
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(3, 4, 5),
  labs = c("five", "three", "four")
)
```

(Seems like a bad idea, but ... okay, user!)

Let's drop these value labels for "gear" and continue playing with other odd scenarios.

```{r}
mtbad <- drop_val1(mtbad, gear)
```

## Too Few Values
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(3),
  labs = c("a", "c")
)
```

## Too Few Labels
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = c(3, 4),
  labs = c("c")
)
```

## Numeric Variables with Decimals 
`add_val_labs()` and `add_val1()` will not allow us to apply value labels to a 
numeric variable that contains decimal values, as this seems like a poor candidate 
for traditional, one-to-one value labeling. If we wish to label ranges of 
numerical values, we can use `add_quant_labs()` or `add_quant1()` to do so.
<br>

"mpg" is a good example of such a variable.

First, it trips the max.unique.vals threshold.

```{r}
mtbad <- add_val1(
  data = mtbad,
  var = mpg,
  vals = c(13),
  labs = c("good")
)
```

Let's relax the max.unique.vals threshold and see what happens.
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = mpg,
  vals = c(13),
  labs = c("good"), max.unique.vals = 50
)
```

This still does not work, because `add_val*` functions don't like variables with 
decimals. Numeric variables with decimal values seem like poor candidates for 
value labels, so, labelr refuses to accept them.

### Getting Rid of Decimals (Approach 1)
Let's try to fix this by eliminating the decimals (We'll try another way in a moment).

To keep things clear, we'll add to mtbad a new variable called "mpg2".

```{r}
mtbad$mpg2 <- floor(mtbad$mpg)
```

"mpg2" is now a compatible variable, and it works this time (if we bump up the
max.unique.vals parameter).

Specifically, check out the label for "mpg2"==13.

```{r}
mtbad <- add_val1(
  data = mtbad,
  var = mpg2, # Note this is the "mpg2" we just created
  vals = c(13),
  labs = c("good"), max.unique.vals = 40
)
```

### Getting Rid of Decimals (Approach 2)
Lets' try a different approach  - make "mpg" a character variable.
To keep things clear, we'll assign it to a new variable called "mpg3".
Then, we'll try to value-label that

```{r}
mtbad$mpg3 <- as.character(mtbad$mpg)
unique(mtbad$mpg3)
```

"mpg3" is now a compatible variable (again, if we increase max.unique.vals).
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = mpg3, # Note this is the "mpg3" we just created
  vals = c("24.4"),
  labs = c("MY-LUCKY-NUMBER"), max.unique.vals = 40
)
```
### Handling Decimals (Approach 3)
Finally, let's try the `add_quant_labs()` approach. Here, we applying a label to 
an entire range of values, i.e., relaxing the strict one-to-one-mapping 
requirement imposed by `add_val_labs()` and `add_val1()`.

```{r}
# create two more copies of mpg
mtbad$mpg4 <- mtbad$mpg
mtbad$mpg5 <- mtbad$mpg

# these are numeric
class(mtbad$mpg4)
class(mtbad$mpg5)

# add quintile range labels for "mpg4"
mtbad2 <- add_quant_labs(data = mtbad, vars = "mpg4", qtiles = 5)

# for "mpg5", add numerical range labels based on "pretty" cuts
# bound bins using range of "mpg" vals
mpg_bins <- pretty(range(mtbad2$mpg5, na.rm = TRUE))
mpg_bins

mtbad2 <- add_quant_labs(
  data = mtbad2,
  vars = "mpg5",
  vals = mpg_bins
) # assign labels using our "pretty" thresholds

# see what these approaches get us
somel(mtbad2, 8)[c("mpg", "mpg4", "mpg5")]

# remove mtbad2
rm(mtbad2)
```

## Do Not Try to Manually Label Irregular Values
labelr identifies certain types of values (e.g., NA, Inf, NaN) as "irregular" and
forces the label "NA" on them all. You can NOT override this (see also the NA/irregular
values vignette).

### Trying to Label an Irregular Value (-Inf)
```{r}
mtbad <- drop_val1(mtbad, gear)
mtbad <- add_val1(
  data = mtbad,
  var = gear,
  vals = -Inf,
  labs = c("neg.inf")
)
```

### Trying to Label an Irregular Value (NA)
```{r}
mtbad <- add_val_labs(
  data = mtbad,
  vars = "grade",
  vals = NA,
  labs = c("miss")
)
```

### Trying to Label an Irregular Value (NaN)
```{r}
mtbad <- add_val_labs(
  data = mtbad,
  vars = "carb",
  vals = NaN,
  labs = c("nan-v")
)
```

### Trying to Label an Irregular Value ("NAN")
Note - labelr also treats "character variants" of irregular values, like "NA" or 
"inf" (not case-sensitive) as irregular values.
```{r}
mtbad <- add_val1(
  data = mtbad,
  var = carb,
  vals = "NAN",
  labs = c("nan-v")
)
```

## Automatically Initialize Value Labels
If we set the init argument to TRUE, our `add_val_labs` `or add_val1` call
will automatically apply provisional value labels to all variables that fall
within our max.unique.vals limit (if they do not already have value labels).

We'll start by dropping all value labels, to give us a clean slate.
```{r}
mtbad <- drop_val_labs(mtbad)
```

See where this leaves our value labels.
```{r}
get_val_labs(mtbad)
```

Now, let's add value labels for "am" only, while turning on the init argument.
```{r}
mtbad <- add_val_labs(
  data = mtbad,
  vars = "am",
  vals = c(0, 1),
  labs = c("auto", "stick"),
  max.unique.vals = 10,
  init = TRUE
)

get_val_labs(mtbad)
```

Non-decimal-having variables within the max.unique.vals threshold have received
placeholder value labels.
