% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_quant1.R
\name{add_quant1}
\alias{add_quant1}
\alias{aql1}
\title{Associate Numerical Threshold-based Value Labels with a Single Numerical Variable}
\usage{
add_quant1(data, var, qtiles = NULL, vals = NULL, labs = NULL)

aql1(data, var, qtiles = NULL, vals = NULL, labs = NULL)
}
\arguments{
\item{data}{a data.frame.}

\item{var}{the unquoted name of the variable to which value labels will be
added.}

\item{qtiles}{the number of quantile categories to employ (e.g., 4 would
indicate quartiles, 5 would indicate quintiles, 10 for deciles, etc.). If
NULL, vals must be non-NULL.}

\item{vals}{one more values of var that will define range cutpoints, such
that all values at or below a given number and above the preceding val will
be treated as part of the same numerical range for labeling purposes. If
NULL, qtiles must be non-NULL.}

\item{labs}{a character vector of distinct labels to identify the
quantiles. If left NULL, convention "q" + quantile (e.g., "q10") will be used
for qtile-based labels (i.e., if qtiles arg is non-NULL), and convention
"<=" + val will be used for vals argument-based labels (i.e., if vals arg is
non-NULL). Note that the labels "NA" and "Other" are (non-case-sensitively)
reserved and may not be user-supplied.}
}
\value{
A data.frame, with new variable value labels added (call
\code{get_val_labs} to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
}
\description{
Add variable-specific value labels based on threshold cuts of a single
numerical variable.
}
\details{
Note: \code{aql1} is a compact alias for \code{add_quant1}: they do the same thing, and
the former is easier to type

Note: \code{add_quant1} is a variant of \code{add_quant_labs} that allows you to specify
only one var to label at a time but that allows you to pass its name without
quoting it (compare add_quant1(mtcars, mpg) to add_quant_labs(mtcars, "mpg").

Numerical variables that feature decimals or large numbers of distinct values
are not eligible to receive conventional value labels. Like \code{add_quant_labs},
\code{add_quant1} allows one to label such variables according to user-supplied
value thresholds or quantile membership, with the assigned value label
meta-data attribute indicating the upper bound (inclusive) of numerical values
of the variable (column) that fall within that label. This approach to
value-labeling deviates from labelr's general requirement that there be a
one-to-one mapping between distinct labels and distinct variable values (see
also \code{add_m1_lab}).

Note: Quantity labels cannot be added incrementally through repeated calls
to \code{add_quant_labs}: each new call will overwrite all value labels that may
have been applied to the specified var in any previous \code{add_quant1} or
\code{add_quant_labs} calls.

This is in contrast to \code{add_val_labs} and \code{add_val1}, which do allow for
incremental value-labeling through repeated calls that build upon earlier
calls.
}
\examples{
# mtcars demo
df <- mtcars
# now, add value labels
df <- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# label variable "mpg" in terms of 5 quintiles
df <- add_quant1(data = df, mpg, qtiles = 5)

# label variable "disp" in terms of "pretty" cutpoints
vals2use <- pretty(c(min(df$disp), max(df$disp)))[-1] # establish cutpoints
df <- add_quant1(data = df, disp, vals = vals2use)
df_labson <- use_val_labs(df)
head(df_labson)
}
